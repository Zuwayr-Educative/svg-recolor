<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive SVG Recoloring App</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f5f5;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .header {
            background: #10265D;
            color: white;
            padding: 24px;
            text-align: center;
        }

        .header h1 {
            font-size: 28px;
            font-weight: 700;
            margin-bottom: 8px;
        }

        .header p {
            opacity: 0.9;
            font-size: 16px;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 24px;
            padding: 24px;
        }

        .section {
            background: #fafafa;
            border-radius: 8px;
            padding: 20px;
        }

        .section-title {
            font-size: 18px;
            font-weight: 600;
            color: #333;
            margin-bottom: 16px;
            padding-bottom: 8px;
            border-bottom: 2px solid #e0e0e0;
        }

        .file-input-area {
            border: 2px dashed #ccc;
            border-radius: 8px;
            padding: 40px;
            text-align: center;
            transition: all 0.3s ease;
            cursor: pointer;
            margin-bottom: 20px;
        }

        .file-input-area:hover {
            border-color: #667eea;
            background-color: #f8f9ff;
        }

        .file-input-area.dragover {
            border-color: #667eea;
            background-color: #f0f4ff;
            transform: scale(1.02);
        }

        #file-input {
            display: none;
        }

        .upload-text {
            font-size: 16px;
            color: #666;
            margin-bottom: 8px;
        }

        .upload-subtext {
            font-size: 14px;
            color: #999;
        }

        .svg-preview {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            background: white;
            min-height: 300px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 20px;
            position: relative;
        }

        .svg-preview svg {
            max-width: 100%;
            max-height: 280px;
            cursor: pointer;
        }

        .svg-preview .clickable-element {
            cursor: pointer;
            transition: opacity 0.2s ease;
        }

        .svg-preview .clickable-element:hover {
            opacity: 0.8;
            stroke: #667eea;
            stroke-width: 2;
        }

        .preview-placeholder {
            color: #999;
            font-style: italic;
        }

        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin-bottom: 20px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
        }

        .control-group label {
            font-weight: 500;
            color: #555;
            margin-bottom: 6px;
            font-size: 14px;
        }

        .control-group input,
        .control-group select {
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.2s ease;
        }

        .control-group input:focus,
        .control-group select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .palette-section {
            margin-bottom: 20px;
        }

        .palette-colors {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 12px;
        }

        .palette-color {
            width: 50px;
            height: 50px;
            border-radius: 6px;
            border: 2px solid #ddd;
            cursor: pointer;
            position: relative;
            transition: all 0.2s ease;
        }

        .palette-color:hover {
            transform: scale(1.1);
            border-color: #667eea;
        }

        .palette-color.selected {
            border-color: #667eea;
            border-width: 3px;
            box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.3);
        }

        .palette-color .remove-btn {
            position: absolute;
            top: -6px;
            right: -6px;
            width: 20px;
            height: 20px;
            background: #ff4444;
            color: white;
            border: none;
            border-radius: 50%;
            font-size: 12px;
            cursor: pointer;
            display: none;
        }

        .palette-color:hover .remove-btn {
            display: block;
        }

        .add-color-btn {
            background: #10265D;
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            margin-right: 8px;
        }

        .add-color-btn:hover {
            background: #10265D;
        }

        .action-buttons {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s ease;
        }

        .btn-primary {
            background: #10265D;
            color: white;
        }

        .btn-primary:hover {
            background: #5a6fd8;
            transform: translateY(-1px);
        }

        .btn-secondary {
            background: #f0f0f0;
            color: #333;
            border: 1px solid #ddd;
        }

        .btn-secondary:hover {
            background: #e8e8e8;
        }

        .output-preview {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            background: white;
            min-height: 400px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .color-picker-container {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .color-picker {
            width: 40px;
            height: 40px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
        }

        .instruction-banner {
            background: #e7f3ff;
            border: 1px solid #b3d9ff;
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 16px;
            font-size: 14px;
            color: #0066cc;
        }

        .instruction-banner .highlight {
            font-weight: 600;
        }

        .color-status {
            background: #f8f9fa;
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 16px;
            font-size: 14px;
        }

        .current-selection {
            font-weight: 600;
            color: #667eea;
        }

        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            
            .controls-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Interactive SVG Recoloring App</h1>
            <p>Upload an SVG, click on elements to select them, then click a color to recolor!</p>
        </div>

        <div class="main-content">
            <div class="left-panel">
                <div class="section">
                    <div class="section-title">Upload SVG</div>
                    <div class="file-input-area" id="file-drop-area">
                        <div class="upload-text">Click to upload or drag and drop</div>
                        <div class="upload-subtext">SVG files only</div>
                        <input type="file" id="file-input" accept=".svg">
                    </div>
                </div>

                <div class="section">
                    <div class="section-title">Interactive Preview</div>
                    <div class="instruction-banner">
                        ðŸ’¡ <span class="highlight">Click on any part</span> of the SVG below to select it, then choose a color from the palette!
                    </div>
                    <div class="color-status" id="color-status">
                        Click on an SVG element to start recoloring
                    </div>
                    <div class="svg-preview" id="original-preview">
                        <div class="preview-placeholder">No SVG uploaded</div>
                    </div>
                </div>
            </div>

            <div class="right-panel">
                <div class="section">
                    <div class="section-title">Color Palette</div>
                    <div class="palette-colors" id="palette-colors">
                    </div>
                    <div class="color-picker-container">
                        <input type="color" id="color-picker" class="color-picker" value="#667eea">
                        <button class="add-color-btn" id="add-color-btn">Add Color</button>
                    </div>
                </div>

                <div class="section">
                    <div class="section-title">Auto Recoloring</div>
                    <div class="instruction-banner">
                        ðŸŽ¨ Automatically map all colors to your palette using nearest color matching
                    </div>
                    <div class="action-buttons">
                        <button class="btn btn-primary" id="auto-recolor-btn">Auto Recolor to Palette</button>
                        <button class="btn btn-primary" id="auto-recolor-v2-btn">Recolor V2 (Advanced)</button>
                        <button class="btn btn-secondary" id="restore-original">Restore Original</button>
                    </div>
                </div>

                <div class="section">
                    <div class="section-title">Output Settings</div>
                    <div class="controls-grid">
                        <div class="control-group">
                            <label for="output-width">Width (px)</label>
                            <input type="number" id="output-width" value="400" min="10" max="2000">
                        </div>
                        <div class="control-group">
                            <label for="output-height">Height (px)</label>
                            <input type="number" id="output-height" value="400" min="10" max="2000">
                        </div>
                        <div class="control-group">
                            <label for="padding">Padding (px)</label>
                            <input type="number" id="padding" value="24" min="0" max="100">
                        </div>
                        <div class="control-group">
                            <label for="border-radius">Border Radius (px)</label>
                            <input type="number" id="border-radius" value="16" min="0" max="50">
                        </div>
                        <div class="control-group">
                            <label for="background-color">Background Color</label>
                            <input type="color" id="background-color" value="#EEEEFF">
                        </div>
                        <div class="control-group">
                            <label for="maintain-aspect">Aspect Ratio</label>
                            <select id="maintain-aspect">
                                <option value="true">Maintain</option>
                                <option value="false">Stretch</option>
                            </select>
                        </div>
                    </div>
                </div>

                <div class="section">
                    <div class="section-title">Actions</div>
                    <div class="action-buttons">
                        <button class="btn btn-secondary" id="download-btn">Download</button>
                        <button class="btn btn-secondary" id="reset-btn">Reset</button>
                    </div>
                </div>

                <div class="section">
                    <div class="section-title">Output Preview</div>
                    <div class="output-preview" id="output-preview">
                        <div class="preview-placeholder">Recolored SVG will appear here</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        class InteractiveSVGRecolorApp {
            constructor() {
                this.originalSVG = null;
                this.currentSVG = null;
                this.palette = [];
                this.selectedColor = null;
                this.selectedElement = null;
                this.elementColors = new Map(); // Track original colors of elements
                this.currentColors = new Set(); // Track all detected colors
                
                this.initializeElements();
                this.bindEvents();
                this.loadDefaultPalette();
            }

            initializeElements() {
                this.fileInput = document.getElementById('file-input');
                this.dropArea = document.getElementById('file-drop-area');
                this.originalPreview = document.getElementById('original-preview');
                this.outputPreview = document.getElementById('output-preview');
                this.paletteContainer = document.getElementById('palette-colors');
                this.colorPicker = document.getElementById('color-picker');
                this.addColorBtn = document.getElementById('add-color-btn');
                this.downloadBtn = document.getElementById('download-btn');
                this.resetBtn = document.getElementById('reset-btn');
                this.colorStatus = document.getElementById('color-status');
                this.autoRecolorBtn = document.getElementById('auto-recolor-btn');
                this.autoRecolorV2Btn = document.getElementById('auto-recolor-v2-btn');
                this.restoreOriginalBtn = document.getElementById('restore-original');
                
                this.outputWidth = document.getElementById('output-width');
                this.outputHeight = document.getElementById('output-height');
                this.padding = document.getElementById('padding');
                this.borderRadius = document.getElementById('border-radius');
                this.backgroundColor = document.getElementById('background-color');
                this.maintainAspect = document.getElementById('maintain-aspect');
            }

            bindEvents() {
                this.fileInput.addEventListener('change', (e) => this.handleFileUpload(e));
                this.dropArea.addEventListener('click', () => this.fileInput.click());
                this.dropArea.addEventListener('dragover', (e) => this.handleDragOver(e));
                this.dropArea.addEventListener('drop', (e) => this.handleDrop(e));
                this.dropArea.addEventListener('dragleave', (e) => this.handleDragLeave(e));
                
                this.addColorBtn.addEventListener('click', () => this.addColorToPalette());
                this.downloadBtn.addEventListener('click', () => this.downloadSVG());
                this.resetBtn.addEventListener('click', () => this.reset());
                this.autoRecolorBtn.addEventListener('click', () => this.autoRecolorToPalette());
                this.autoRecolorV2Btn.addEventListener('click', () => this.autoRecolorV2ToPalette());
                this.restoreOriginalBtn.addEventListener('click', () => this.restoreOriginal());
                
                // Add click-outside detection to clear selection
                document.addEventListener('click', (e) => this.handleDocumentClick(e));
                
                this.outputWidth.addEventListener('input', () => this.updateOutput());
                this.outputHeight.addEventListener('input', () => this.updateOutput());
                this.padding.addEventListener('input', () => this.updateOutput());
                this.borderRadius.addEventListener('input', () => this.updateOutput());
                this.backgroundColor.addEventListener('input', () => this.updateOutput());
                this.maintainAspect.addEventListener('change', () => this.updateOutput());
            }

            handleDragOver(e) {
                e.preventDefault();
                this.dropArea.classList.add('dragover');
            }

            handleDragLeave(e) {
                e.preventDefault();
                this.dropArea.classList.remove('dragover');
            }

            handleDrop(e) {
                e.preventDefault();
                this.dropArea.classList.remove('dragover');
                const files = e.dataTransfer.files;
                if (files.length > 0 && files[0].type === 'image/svg+xml') {
                    this.processFile(files[0]);
                }
            }

            handleFileUpload(e) {
                const file = e.target.files[0];
                if (file && file.type === 'image/svg+xml') {
                    this.processFile(file);
                }
            }

            isBase64SVG(data) {
                // Check if the data starts with 'data:image/svg+xml;base64,'
                if (typeof data === 'string' && data.startsWith('data:image/svg+xml;base64,')) {
                    return true;
                }
                return false;
            }

            extractNestedBase64SVG(svgString) {
                try {
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(svgString, 'image/svg+xml');
                    const images = doc.getElementsByTagName('image');
                    let modified = false;

                    for (let img of images) {
                        const href = img.getAttributeNS('http://www.w3.org/1999/xlink', 'href');
                        if (href && this.isBase64SVG(href)) {
                            const decoded = this.decodeBase64SVG(href);
                            if (decoded && decoded.includes('<svg')) {
                                // Create a temporary div to parse the SVG
                                const tempDiv = document.createElement('div');
                                tempDiv.innerHTML = decoded;
                                const svgElement = tempDiv.querySelector('svg');
                                
                                if (svgElement) {
                                    // Copy attributes from image to the new SVG
                                    for (let i = 0; i < img.attributes.length; i++) {
                                        const attr = img.attributes[i];
                                        if (attr.name !== 'xlink:href' && attr.name !== 'xmlns:xlink') {
                                            svgElement.setAttribute(attr.name, attr.value);
                                        }
                                    }
                                    
                                    // Replace the image with the decoded SVG
                                    img.parentNode.replaceChild(svgElement, img);
                                    modified = true;
                                }
                            }
                        }
                    }

                    return modified ? new XMLSerializer().serializeToString(doc.documentElement) : svgString;
                } catch (error) {
                    console.error('Error processing nested base64 SVG:', error);
                    return svgString;
                }
            }

            decodeBase64SVG(base64Data) {
                try {
                    // Remove the data URL prefix
                    const base64String = base64Data.split('base64,')[1];
                    if (!base64String) return null;
                    
                    // Decode the base64 string
                    const decodedString = atob(base64String);
                    return decodedString;
                } catch (error) {
                    console.error('Error decoding base64 SVG:', error);
                    return null;
                }
            }

            processFile(file) {
                const reader = new FileReader();
                
                reader.onload = (e) => {
                    try {
                        let fileContent = e.target.result;
                        
                        // First, try to read as text
                        if (typeof fileContent === 'string') {
                            // Process any nested base64 SVGs in image elements
                            fileContent = this.extractNestedBase64SVG(fileContent);
                            
                            // Check if it's a base64 data URL
                            if (this.isBase64SVG(fileContent)) {
                                const decodedSVG = this.decodeBase64SVG(fileContent);
                                if (decodedSVG && decodedSVG.includes('<svg')) {
                                    this.originalSVG = decodedSVG;
                                    this.currentSVG = decodedSVG;
                                    this.displayInteractiveSVG();
                                    return;
                                }
                            }
                            
                            // If it's not base64 but contains SVG, use it directly
                            if (fileContent.includes('<svg')) {
                                this.originalSVG = fileContent;
                                this.currentSVG = fileContent;
                                this.displayInteractiveSVG();
                                return;
                            }
                        }
                        
                        // If we get here, try reading as binary
                        const binaryReader = new FileReader();
                        binaryReader.onload = (binaryEvent) => {
                            try {
                                const binaryData = binaryEvent.target.result;
                                const decoder = new TextDecoder('utf-8');
                                const text = decoder.decode(new Uint8Array(binaryData));
                                
                                if (text.includes('<svg')) {
                                    this.originalSVG = text;
                                    this.currentSVG = text;
                                    this.displayInteractiveSVG();
                                } else {
                                    throw new Error('File does not contain valid SVG data');
                                }
                            } catch (error) {
                                console.error('Error processing binary data:', error);
                                alert('Error: Could not process the file. Please make sure it is a valid SVG file.');
                            }
                        };
                        
                        binaryReader.onerror = (error) => {
                            console.error('Error reading binary data:', error);
                            alert('Error reading file. Please try again.');
                        };
                        
                        binaryReader.readAsArrayBuffer(file);
                        
                    } catch (error) {
                        console.error('Error processing file:', error);
                        alert('Error processing file. Please try again.');
                    }
                };
                
                reader.onerror = (error) => {
                    console.error('Error reading file:', error);
                    alert('Error reading file. Please try again.');
                };
                
                // First try reading as text
                reader.readAsText(file);
            }

            displayInteractiveSVG() {
                this.originalPreview.innerHTML = this.currentSVG;
                const svg = this.originalPreview.querySelector('svg');
                
                if (svg) {
                    svg.style.maxWidth = '100%';
                    svg.style.maxHeight = '100%';
                    this.makeElementsClickable(svg);
                    this.extractColors();
                    this.updateOutput();
                }
            }

            makeElementsClickable(svg) {
                // Find all elements that have fill or stroke
                const elements = svg.querySelectorAll('*');
                
                elements.forEach((element, index) => {
                    const fill = element.getAttribute('fill');
                    const stroke = element.getAttribute('stroke');
                    const style = element.getAttribute('style');
                    
                    let hasColor = false;
                    if (fill && fill !== 'none' && fill !== 'transparent') hasColor = true;
                    if (stroke && stroke !== 'none' && stroke !== 'transparent') hasColor = true;
                    if (style && (style.includes('fill:') || style.includes('stroke:'))) hasColor = true;
                    
                    if (hasColor) {
                        element.classList.add('clickable-element');
                        element.dataset.elementId = index;
                        
                        // Store original color
                        this.elementColors.set(index, this.getElementColor(element));
                        
                        element.addEventListener('click', (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            this.selectElement(element, index);
                        });
                    }
                });
            }

            getElementColor(element) {
                const fill = element.getAttribute('fill');
                const stroke = element.getAttribute('stroke');
                const style = element.getAttribute('style');
                
                // Priority: fill > stroke > style
                if (fill && fill !== 'none' && fill !== 'transparent') {
                    return { type: 'fill', color: fill };
                }
                if (stroke && stroke !== 'none' && stroke !== 'transparent') {
                    return { type: 'stroke', color: stroke };
                }
                if (style) {
                    const fillMatch = style.match(/fill:\s*([^;]+)/);
                    const strokeMatch = style.match(/stroke:\s*([^;]+)/);
                    if (fillMatch && fillMatch[1] !== 'none' && fillMatch[1] !== 'transparent') {
                        return { type: 'style-fill', color: fillMatch[1].trim() };
                    }
                    if (strokeMatch && strokeMatch[1] !== 'none' && strokeMatch[1] !== 'transparent') {
                        return { type: 'style-stroke', color: strokeMatch[1].trim() };
                    }
                }
                return null;
            }

            selectElement(element, elementId) {
                this.clearSelection();
                
                // Select new element
                this.selectedElement = { element, elementId };
                element.classList.add('selected-element');
                element.style.outline = '3px solid #667eea';
                
                const colorInfo = this.elementColors.get(elementId);
                this.colorStatus.innerHTML = `
                    <span class="current-selection">Selected:</span> 
                    ${element.tagName.toLowerCase()} element 
                    <span style="display:inline-block; width:20px; height:20px; background:${colorInfo.color}; border-radius:3px; vertical-align:middle; margin:0 4px; border:1px solid #ddd;"></span>
                    ${colorInfo.color}
                `;
            }

            clearSelection() {
                // Remove previous selection
                const previousSelected = this.originalPreview.querySelector('.selected-element');
                if (previousSelected) {
                    previousSelected.classList.remove('selected-element');
                    previousSelected.style.outline = '';
                }
                this.selectedElement = null;
            }

            handleDocumentClick(e) {
                // Check if click is outside the SVG preview area
                if (!this.originalPreview.contains(e.target)) {
                    this.clearSelection();
                    this.colorStatus.innerHTML = 'Click on an SVG element to start recoloring';
                }
            }

            selectPaletteColor(color) {
                // Remove previous selection
                document.querySelectorAll('.palette-color').forEach(el => {
                    el.classList.remove('selected');
                });
                
                // Select new color
                this.selectedColor = color;
                const colorElement = document.querySelector(`[data-color="${color}"]`);
                if (colorElement) {
                    colorElement.classList.add('selected');
                }
                
                // Apply color if element is selected
                if (this.selectedElement) {
                    this.applyColorToSelectedElement(color);
                }
            }

            applyColorToSelectedElement(color) {
                if (!this.selectedElement) return;
                
                const { element, elementId } = this.selectedElement;
                const colorInfo = this.elementColors.get(elementId);
                
                // Apply color based on original type
                if (colorInfo.type === 'fill') {
                    element.setAttribute('fill', color);
                } else if (colorInfo.type === 'stroke') {
                    element.setAttribute('stroke', color);
                } else if (colorInfo.type === 'style-fill') {
                    let style = element.getAttribute('style') || '';
                    style = style.replace(/fill:\s*[^;]+/, `fill: ${color}`);
                    element.setAttribute('style', style);
                } else if (colorInfo.type === 'style-stroke') {
                    let style = element.getAttribute('style') || '';
                    style = style.replace(/stroke:\s*[^;]+/, `stroke: ${color}`);
                    element.setAttribute('style', style);
                }
                
                // Update current SVG
                this.currentSVG = this.originalPreview.innerHTML;
                this.updateOutput();
                
                // Update status
                this.colorStatus.innerHTML = `
                    <span class="current-selection">Applied:</span> 
                    ${color} to ${element.tagName.toLowerCase()} element
                    <span style="display:inline-block; width:20px; height:20px; background:${color}; border-radius:3px; vertical-align:middle; margin:0 4px; border:1px solid #ddd;"></span>
                `;
            }

            addColorToPalette() {
                const color = this.colorPicker.value;
                if (!this.palette.includes(color)) {
                    this.palette.push(color);
                    this.updatePaletteDisplay();
                }
            }

            updatePaletteDisplay() {
                this.paletteContainer.innerHTML = '';
                this.palette.forEach((color, index) => {
                    const colorDiv = document.createElement('div');
                    colorDiv.className = 'palette-color';
                    colorDiv.style.backgroundColor = color;
                    colorDiv.title = color;
                    colorDiv.dataset.color = color;
                    
                    const removeBtn = document.createElement('button');
                    removeBtn.className = 'remove-btn';
                    removeBtn.textContent = 'Ã—';
                    removeBtn.onclick = (e) => {
                        e.stopPropagation();
                        this.palette.splice(index, 1);
                        this.updatePaletteDisplay();
                    };
                    
                    colorDiv.appendChild(removeBtn);
                    colorDiv.addEventListener('click', () => this.selectPaletteColor(color));
                    this.paletteContainer.appendChild(colorDiv);
                });
            }

            loadDefaultPalette() {
                this.palette = ['#FFFFFF', '#5553FF', '#EF2E98', '#4ADE80', '#10265D', '#FFDE00', '#0C1322'];
                this.updatePaletteDisplay();
            }


            extractColors() {
                this.currentColors.clear();
                const parser = new DOMParser();
                const svgDoc = parser.parseFromString(this.currentSVG, 'image/svg+xml');
                
                const elements = svgDoc.querySelectorAll('*');
                elements.forEach(el => {
                    const fill = el.getAttribute('fill');
                    const stroke = el.getAttribute('stroke');
                    
                    if (fill && fill !== 'none' && fill !== 'transparent') {
                        this.currentColors.add(this.normalizeColor(fill));
                    }
                    if (stroke && stroke !== 'none' && stroke !== 'transparent') {
                        this.currentColors.add(this.normalizeColor(stroke));
                    }
                    
                    const style = el.getAttribute('style');
                    if (style) {
                        const fillMatch = style.match(/fill:\s*([^;]+)/);
                        const strokeMatch = style.match(/stroke:\s*([^;]+)/);
                        
                        if (fillMatch && fillMatch[1] !== 'none' && fillMatch[1] !== 'transparent') {
                            this.currentColors.add(this.normalizeColor(fillMatch[1]));
                        }
                        if (strokeMatch && strokeMatch[1] !== 'none' && strokeMatch[1] !== 'transparent') {
                            this.currentColors.add(this.normalizeColor(strokeMatch[1]));
                        }
                    }
                });
            }

            normalizeColor(color) {
                if (!color || typeof color !== 'string') return null;
                
                const trimmedColor = color.trim();
                if (!trimmedColor || trimmedColor === 'none' || trimmedColor === 'transparent') return null;
                
                const div = document.createElement('div');
                div.style.color = trimmedColor;
                document.body.appendChild(div);
                const computedColor = window.getComputedStyle(div).color;
                document.body.removeChild(div);
                
                const match = computedColor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
                if (match) {
                    const r = parseInt(match[1]);
                    const g = parseInt(match[2]);
                    const b = parseInt(match[3]);
                    return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
                }
                return trimmedColor;
            }

            findNearestColor(targetColor) {
                if (this.palette.length === 0) return targetColor;
                
                const target = this.hexToRgb(targetColor);
                let nearest = this.palette[0];
                let minDistance = Infinity;
                
                this.palette.forEach(paletteColor => {
                    const palette = this.hexToRgb(paletteColor);
                    const distance = Math.sqrt(
                        Math.pow(target.r - palette.r, 2) +
                        Math.pow(target.g - palette.g, 2) +
                        Math.pow(target.b - palette.b, 2)
                    );
                    
                    if (distance < minDistance) {
                        minDistance = distance;
                        nearest = paletteColor;
                    }
                });
                
                return nearest;
            }

            hexToRgb(hex) {
                const r = parseInt(hex.slice(1, 3), 16);
                const g = parseInt(hex.slice(3, 5), 16);
                const b = parseInt(hex.slice(5, 7), 16);
                return { r, g, b };
            }

            autoRecolorToPalette() {
                if (!this.originalSVG || this.palette.length === 0) {
                    alert('Please upload an SVG and set up your color palette first.');
                    return;
                }
                
                const parser = new DOMParser();
                const svgDoc = parser.parseFromString(this.originalSVG, 'image/svg+xml');
                const elements = svgDoc.querySelectorAll('*');
                
                // Create color mapping
                const colorMap = new Map();
                Array.from(this.currentColors).forEach(originalColor => {
                    const nearestColor = this.findNearestColor(originalColor);
                    colorMap.set(originalColor.toLowerCase(), nearestColor);
                });
                
                // Update elements
                elements.forEach(el => {
                    // Handle fill attribute
                    const fill = el.getAttribute('fill');
                    if (fill && fill !== 'none' && fill !== 'transparent') {
                        const normalizedFill = this.normalizeColor(fill);
                        const newColor = colorMap.get(normalizedFill.toLowerCase());
                        if (newColor) {
                            el.setAttribute('fill', newColor);
                        }
                    }
                    
                    // Handle stroke attribute
                    const stroke = el.getAttribute('stroke');
                    if (stroke && stroke !== 'none' && stroke !== 'transparent') {
                        const normalizedStroke = this.normalizeColor(stroke);
                        const newColor = colorMap.get(normalizedStroke.toLowerCase());
                        if (newColor) {
                            el.setAttribute('stroke', newColor);
                        }
                    }
                    
                    // Handle style attribute
                    const style = el.getAttribute('style');
                    if (style) {
                        let newStyle = style;
                        
                        // Replace fill in style
                        const fillMatch = style.match(/fill:\s*([^;]+)/);
                        if (fillMatch && fillMatch[1] !== 'none' && fillMatch[1] !== 'transparent') {
                            const normalizedFill = this.normalizeColor(fillMatch[1].trim());
                            const newColor = colorMap.get(normalizedFill.toLowerCase());
                            if (newColor) {
                                newStyle = newStyle.replace(/fill:\s*[^;]+/, `fill: ${newColor}`);
                            }
                        }
                        
                        // Replace stroke in style
                        const strokeMatch = style.match(/stroke:\s*([^;]+)/);
                        if (strokeMatch && strokeMatch[1] !== 'none' && strokeMatch[1] !== 'transparent') {
                            const normalizedStroke = this.normalizeColor(strokeMatch[1].trim());
                            const newColor = colorMap.get(normalizedStroke.toLowerCase());
                            if (newColor) {
                                newStyle = newStyle.replace(/stroke:\s*[^;]+/, `stroke: ${newColor}`);
                            }
                        }
                        
                        if (newStyle !== style) {
                            el.setAttribute('style', newStyle);
                        }
                    }
                });
                
                this.currentSVG = new XMLSerializer().serializeToString(svgDoc);
                this.displayInteractiveSVG();
                
                this.colorStatus.innerHTML = `
                    <span class="current-selection">Auto Recolored:</span> 
                    Applied ${colorMap.size} color mappings to palette
                `;
            }

            restoreOriginal() {
                if (!this.originalSVG) {
                    alert('No original SVG to restore.');
                    return;
                }
                
                this.currentSVG = this.originalSVG;
                this.displayInteractiveSVG();
                
                this.colorStatus.innerHTML = 'Original colors restored - click on an element to start recoloring';
            }

            // Advanced color functions for V2 recoloring
            hexToRgbV2(hex) {
                if (!hex || typeof hex !== 'string' || !hex.startsWith('#') || hex.length !== 7) return null;
                const r = parseInt(hex.slice(1, 3), 16);
                const g = parseInt(hex.slice(3, 5), 16);
                const b = parseInt(hex.slice(5, 7), 16);
                if (isNaN(r) || isNaN(g) || isNaN(b)) return null;
                return { r, g, b };
            }

            rgbToXyz(r, g, b) {
                // Convert RGB to XYZ color space
                r = r / 255;
                g = g / 255;
                b = b / 255;

                r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
                g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
                b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;

                r *= 100;
                g *= 100;
                b *= 100;

                const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
                const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
                const z = r * 0.0193 + g * 0.1192 + b * 0.9505;

                return { x, y, z };
            }

            xyzToLab(x, y, z) {
                // Convert XYZ to LAB color space
                const xn = 95.047; // D65 illuminant
                const yn = 100.000;
                const zn = 108.883;

                x = x / xn;
                y = y / yn;
                z = z / zn;

                x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x + 16/116);
                y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y + 16/116);
                z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z + 16/116);

                const l = (116 * y) - 16;
                const a = 500 * (x - y);
                const b = 200 * (y - z);

                return { l, a, b };
            }

            hexToLab(hex) {
                const rgb = this.hexToRgbV2(hex);
                if (!rgb) return null;
                const xyz = this.rgbToXyz(rgb.r, rgb.g, rgb.b);
                return this.xyzToLab(xyz.x, xyz.y, xyz.z);
            }

            deltaE76(lab1, lab2) {
                // Calculate color difference using CIE76 formula
                if (!lab1 || !lab2) return Infinity;
                const deltaL = lab1.l - lab2.l;
                const deltaA = lab1.a - lab2.a;
                const deltaB = lab1.b - lab2.b;
                return Math.sqrt(deltaL * deltaL + deltaA * deltaA + deltaB * deltaB);
            }

            nearestPaletteColorV2(fromHex, paletteHexes) {
                const fromLab = this.hexToLab(fromHex);
                if (!fromLab) return { color: fromHex, d: 0 }; // Return original if can't convert
                
                let best = null;
                for (const p of paletteHexes) {
                    const pLab = this.hexToLab(p);
                    if (!pLab) continue; // Skip invalid palette colors
                    const d = this.deltaE76(fromLab, pLab);
                    if (!best || d < best.d) best = { color: p, d };
                }
                return best || { color: fromHex, d: 0 }; // Fallback to original
            }

            collectColorsFromStyleAttr(style) {
                const colors = [];
                if (!style) return colors;
                
                const props = ['fill', 'stroke', 'stop-color'];
                for (const prop of props) {
                    const regex = new RegExp(`${prop}\\s*:\\s*([^;]+)`, 'gi');
                    let match;
                    while ((match = regex.exec(style)) !== null) {
                        const value = this.normalizeColor(match[1].trim());
                        if (value) {
                            colors.push({ prop, value });
                        }
                    }
                }
                return colors;
            }

            setOrUpdateStyleProp(styleValue, prop, newColor) {
                const decls = styleValue
                    ? styleValue.split(';').map(s => s.trim()).filter(Boolean)
                    : [];
                let replaced = false;
                const out = decls.map(d => {
                    const m = d.match(/^([a-z-]+)\s*:\s*(.+)$/i);
                    if (!m) return d;
                    if (m[1].toLowerCase() === prop.toLowerCase()) {
                        replaced = true;
                        return `${prop}:${newColor}`;
                    }
                    return d;
                });
                if (!replaced) out.push(`${prop}:${newColor}`);
                return out.join('; ');
            }

            gatherDetectedColorsV2(svgDoc) {
                const colors = new Set();
                const all = svgDoc.querySelectorAll('*');
                for (const el of all) {
                    for (const attr of ['fill', 'stroke', 'stop-color']) {
                        const v = el.getAttribute(attr);
                        const n = this.normalizeColor(v);
                        if (n) colors.add(n);
                    }
                    const style = el.getAttribute('style');
                    for (const item of this.collectColorsFromStyleAttr(style)) {
                        colors.add(item.value);
                    }
                }
                return Array.from(colors).sort();
            }

            recolorSvgDocV2(svgDoc, paletteHexes) {
                if (!paletteHexes.length) throw new Error('Palette is empty.');

                const fromColors = this.gatherDetectedColorsV2(svgDoc);
                const mapping = new Map();
                const distances = new Map();
                
                for (const c of fromColors) {
                    const best = this.nearestPaletteColorV2(c, paletteHexes);
                    mapping.set(c, best.color);
                    distances.set(c, best.d);
                }

                const all = svgDoc.querySelectorAll('*');
                for (const el of all) {
                    for (const attr of ['fill', 'stroke', 'stop-color']) {
                        const v = el.getAttribute(attr);
                        const n = this.normalizeColor(v);
                        if (n && mapping.has(n)) el.setAttribute(attr, mapping.get(n));
                    }

                    const style = el.getAttribute('style');
                    if (style) {
                        let next = style;
                        for (const prop of ['fill', 'stroke', 'stop-color']) {
                            const items = this.collectColorsFromStyleAttr(next).filter(
                                x => x.prop === prop
                            );
                            for (const it of items) {
                                if (mapping.has(it.value)) {
                                    next = this.setOrUpdateStyleProp(next, prop, mapping.get(it.value));
                                }
                            }
                        }
                        el.setAttribute('style', next);
                    }
                }

                return { mapping, distances, fromColors };
            }

            autoRecolorV2ToPalette() {
                if (!this.originalSVG || this.palette.length === 0) {
                    alert('Please upload an SVG and set up your color palette first.');
                    return;
                }

                try {
                    const parser = new DOMParser();
                    const svgDoc = parser.parseFromString(this.originalSVG, 'image/svg+xml');
                    
                    const result = this.recolorSvgDocV2(svgDoc, this.palette);
                    
                    this.currentSVG = new XMLSerializer().serializeToString(svgDoc);
                    this.displayInteractiveSVG();
                    
                    this.colorStatus.innerHTML = `
                        <span class="current-selection">Auto Recolored V2:</span> 
                        Applied ${result.mapping.size} advanced color mappings using LAB color space
                    `;
                } catch (error) {
                    alert('Error during V2 recoloring: ' + error.message);
                    console.error('V2 Recoloring error:', error);
                }
            }

            updateOutput() {
                if (!this.currentSVG) return;
                
                const parser = new DOMParser();
                const svgDoc = parser.parseFromString(this.currentSVG, 'image/svg+xml');
                const svg = svgDoc.querySelector('svg');
                
                const width = parseInt(this.outputWidth.value);
                const height = parseInt(this.outputHeight.value);
                const padding = parseInt(this.padding.value);
                const borderRadius = parseInt(this.borderRadius.value);
                const bgColor = this.backgroundColor.value;
                
                const container = document.createElement('div');
                container.style.cssText = `
                    width: ${width}px;
                    height: ${height}px;
                    padding: ${padding}px;
                    background-color: ${bgColor};
                    border-radius: ${borderRadius}px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    overflow: hidden;
                `;
                
                if (svg) {
                    const svgClone = svg.cloneNode(true);
                    svgClone.style.cssText = `
                        max-width: ${width - (padding * 2)}px;
                        max-height: ${height - (padding * 2)}px;
                        width: auto;
                        height: auto;
                    `;
                    
                    // Clean up selection styles from the preview clone
                    const cloneElements = svgClone.querySelectorAll('*');
                    cloneElements.forEach(el => {
                        el.classList.remove('selected-element');
                        el.classList.remove('clickable-element');
                        if (el.style.outline) {
                            el.style.outline = '';
                        }
                    });
                    
                    container.appendChild(svgClone);
                }
                
                this.outputPreview.innerHTML = '';
                this.outputPreview.appendChild(container);
            }

            downloadSVG() {
                if (!this.currentSVG) {
                    alert('Please upload and modify an SVG first.');
                    return;
                }
                
                // Clear any selection before download
                this.clearSelection();
                
                const width = parseInt(this.outputWidth.value);
                const height = parseInt(this.outputHeight.value);
                const padding = parseInt(this.padding.value);
                const borderRadius = parseInt(this.borderRadius.value);
                const bgColor = this.backgroundColor.value;
                
                // Create a clean copy of the SVG without any selection artifacts
                const parser = new DOMParser();
                const svgDoc = parser.parseFromString(this.currentSVG, 'image/svg+xml');
                const recoloredSvgElement = svgDoc.querySelector('svg');
                
                // Clean up any selection classes or inline styles from the download copy
                const elements = svgDoc.querySelectorAll('*');
                elements.forEach(el => {
                    el.classList.remove('selected-element');
                    el.classList.remove('clickable-element');
                    if (el.style.outline) {
                        el.style.outline = '';
                    }
                });
                
                if (!recoloredSvgElement) {
                    alert('Error: Could not parse SVG.');
                    return;
                }
                
                let viewBox = recoloredSvgElement.getAttribute('viewBox');
                if (!viewBox) {
                    const svgWidth = recoloredSvgElement.getAttribute('width') || '100';
                    const svgHeight = recoloredSvgElement.getAttribute('height') || '100';
                    viewBox = `0 0 ${svgWidth} ${svgHeight}`;
                }
                
                const [, , intrinsicWidth, intrinsicHeight] = viewBox.split(' ').map(Number);
                const availableWidth = width - (padding * 2);
                const availableHeight = height - (padding * 2);
                
                const scaleToFitWidth = availableWidth / intrinsicWidth;
                const scaleToFitHeight = availableHeight / intrinsicHeight;
                const finalScale = Math.min(scaleToFitWidth, scaleToFitHeight);
                
                const finalSvgWidth = intrinsicWidth * finalScale;
                const finalSvgHeight = intrinsicHeight * finalScale;
                
                const svgX = padding + (availableWidth - finalSvgWidth) / 2;
                const svgY = padding + (availableHeight - finalSvgHeight) / 2;
                
                const finalSVG = `<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}" viewBox="0 0 ${width} ${height}">
    <defs>
        <clipPath id="roundedCorners">
            <rect x="0" y="0" width="${width}" height="${height}" rx="${borderRadius}" ry="${borderRadius}"/>
        </clipPath>
    </defs>
    <rect width="${width}" height="${height}" fill="${bgColor}" rx="${borderRadius}" ry="${borderRadius}"/>
    <g clip-path="url(#roundedCorners)">
        <svg x="${svgX}" y="${svgY}" width="${finalSvgWidth}" height="${finalSvgHeight}" viewBox="${viewBox}">
            ${recoloredSvgElement.innerHTML}
        </svg>
    </g>
</svg>`;
                
                const blob = new Blob([finalSVG], { type: 'image/svg+xml' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'interactive-recolored-svg.svg';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            reset() {
                this.clearSelection();
                this.originalSVG = null;
                this.currentSVG = null;
                this.selectedElement = null;
                this.selectedColor = null;
                this.elementColors.clear();
                this.currentColors.clear();
                
                this.originalPreview.innerHTML = '<div class="preview-placeholder">No SVG uploaded</div>';
                this.outputPreview.innerHTML = '<div class="preview-placeholder">Recolored SVG will appear here</div>';
                this.colorStatus.innerHTML = 'Click on an SVG element to start recoloring';
                
                this.outputWidth.value = '400';
                this.outputHeight.value = '400';
                this.padding.value = '24';
                this.borderRadius.value = '16';
                this.backgroundColor.value = '#EEEEFF';
                this.maintainAspect.value = 'true';
                
                this.fileInput.value = '';
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            new InteractiveSVGRecolorApp();
        });
    </script>
</body>
</html>
